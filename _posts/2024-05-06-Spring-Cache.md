---
title: Spring Cache part 1
permalink: /posts/2024/05/Spring-Cache-1/
date: 2024-05-06
tags:
  - SpringCache
  - Caching
  - Performance
  - CacheEvict
  - Cacheable
---

최근 한 회사의 코딩 테스트 문제로 Spring Cache에 대한 내용이 있었는데, 처음 들어봤던 내용이라 이번 기회에 한번 알아보고 토이 프로젝트에 적용해보려고 합니다.


# Spring Cache 1편

## Spring Cache란?

### Spring Cache 정의

Spring Cache는 자주 사용되는 데이터를 임시적으로 저장해두어 빠르게 접근할 수 있게 돕는 Spring 프레임워크의 모듈입니다. 이를 통해 애플리케이션의 성능을 향상시키는 것이 가능합니다.

흔히 데이터베이스 조회와 같은 시간이 많이 소요되는 연산의 결과를 캐시에 저장해두면, 이후 동일한 요청이 있을 때는 데이터베이스 조회 없이 캐시에서 결과를 가져올 수 있습니다. 이렇게 하면 데이터베이스에 부담을 줄이면서 동시에 빠른 응답 시간을 제공할 수 있습니다.

### Spring Cache 특징

Spring Cache는 캐싱과 관련된 여러 가지 특징이 있습니다.

- **추상화**: Spring Cache는 다양한 캐시 프로바이더와 통합이 가능합니다. 이를 통해 캐싱 솔루션을 변경할 때에도 애플리케이션 코드에 최소한의 변경만으로도 가능하게 합니다. 예를 들어, EhCache에서 Redis로 캐시 프로바이더를 변경하더라도 어플리케이션 코드의 변경은 거의 없을 것입니다.
- **어노테이션 기반의 선언적 스타일**: Spring Cache는 선언적인 스타일의 프로그래밍을 지원합니다. 즉, 어노테이션을 사용하여 메서드나 클래스에 캐싱을 적용할 수 있으며, 이를 통해 캐싱과 관련된 로직을 비즈니스 로직과 분리할 수 있습니다. 가장 주로 사용되는 어노테이션에는 `@Cacheable`, `@CacheEvict`, `@CachePut` 등이 있습니다.

### Spring Cache 장단점

물론 Spring Cache도 장단점이 있습니다.

#### 장점:
- **프로그램 성능 개선**: 캐시를 사용함으로써 데이터베이스나 외부 시스템과의 통신 요청을 줄일 수 있어, 응답 시간을 향상시키는 것이 가능합니다. 이는 사용자 경험을 향상시키는 데에 중요한 요소입니다.
- **선언적 접근**: Spring Cache의 가장 큰 장점 중 하나는 선언적이라는 것입니다. 코드를 직접 수정하지 않고도 어노테이션을 통해 캐싱 기능을 추가하거나 수정할 수 있습니다. 이는 코드의 가독성을 향상시키고 유지 보수를 용이하게 합니다.

#### 단점:
- **데이터 일관성**: 캐시 데이터와 원본 데이터(DB 등) 사이의 일관성을 유지하는 것은 쉽지 않습니다. 즉, 원본 데이터가 변경되었을 때 이를 캐시에 반영하기 위한 추가적인 로직이 필요합니다.
- **메모리 사용**: 캐시는 데이터를 메모리에 저장하여 사용합니다. 따라서 대량의 데이터를 캐싱하려면 충분한 메모리가 필요합니다.

### Spring Cache 사용 예제

Spring Cache는 매우 사용하기 쉽습니다. 아래에 간단한 사용 예제를 보여드리겠습니다.

```java
@Service
public class ExampleService {

    @Cacheable("items") // items 캐시를 사용
    public String get(Long id) {
        // 가정: 데이터를 가져오는 데 많은 시간이 소요
        return expensiveOperation(id);
    }
    
    @CacheEvict(value = "items", allEntries = true) // 모든 항목 삭제
    public void update(Long id, String update) {
      // 가정: id 를 키로 가지는 항목이 "items" 캐시에서 삭제 됨
    }
    
    // 실제 비용이 많이 드는 연산
    private String expensiveOperation(Long id) {
        return "Item " + id;
    }
}
```

위의 예제에서 get 메서드는 @Cacheable 어노테이션을 사용하여 "items" 캐시에 반환 값을 저장합니다.<br> 
이후 같은 id를 가지고 get 메서드를 호출하면 캐시에서 반환 값을 즉시 가져와, 비용이 많이 드는 expensiveOperation 함수를 다시 실행하지 않아도 됩니다.<br>
이는 시스템의 전체적인 성능 향상을 가져옵니다.<br>

update 메서드에서는 @CacheEvict 어노테이션을 사용하여 "items" 캐시에서 특정 항목을 삭제합니다. <br>
allEntries = true 옵션은 모든 항목을 삭제하도록 지시합니다. <br>
이렇게 함으로써, 업데이트가 이루어진 후에는 오래된 데이터를 사용하는 대신 새롭고 업데이트 된 정보를 가져오게 됩니다.


적절한 캐시 전략을 사용하면 비용이 많이 드는 연산을 최소화하고, 애플리케이션의 응답 시간을 대폭 줄일 수 있습니다. 그럼에도 불구하고, 캐시를 사용함으로써 발생할 수 있는 데이터 일관성 문제와 메모리 관리 문제와 같은 다양한 요소들을 고려하며 적절한 캐시 전략을 선택해야 합니다.

또한, Spring Cache는 여러 캐시 프로바이더와의 통합을 지원하므로, 애플리케이션의 요구 사항과 환경에 따라 적절한 캐시 솔루션을 선택할 수 있습니다.

마지막으로, 선언적인 캐싱 방식을 통해, 개발자는 비즈니스 로직에 집중하면서도 성능 이슈를 효과적으로 해결할 수 있습니다.